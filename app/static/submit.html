<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Submit | Tocky</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.9.2/dist/semantic.min.css" />
    <style>
        .carousel {
            display: flex;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .carousel img {
            border-radius: 5px;
            margin: 5px;
        }

        .carousel img.greyed-out {
            filter: grayscale(100%);
        }

        .carousel div {
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="app">
        <form class="ui form container">
            <p-fieldset legend="Input Book" :toggleable="true">
                <div class="ui segment basic">
                    <div class="ui two column very relaxed stackable grid">
                        <div class="column field">
                            <label>Internet Archive ID</label>
                            <input type="text" name="ia_id" v-model="ia_id" placeholder="e.g. goody">
                        </div>

                        <div class="column field">
                            <label>Open Library ID</label>
                            <input type="text" name="ol_id" v-model="ol_id" placeholder="e.g. OL123M" pattern="^OL\d+M$">
                        </div>
                    </div>
                    <div class="ui vertical divider">or</div>
                </div>
            </p-fieldset>

            <p-fieldset legend="Detector" :toggleable="true">
                <p>
                    Given a book, this phase is responsible for finding the pages that contain
                    the table of contents in a book.
                </p>
                
                <div class="ui segment basic">
                    <p-float-label>
                        <p-select v-model="detector" :options="detector_options" option-label="name"></p-select>
                        <label>Detector</label>
                    </p-float-label>
                </div>

                <p-fieldset legend="OCR Detector Options" :toggleable="true" v-if="detector == DETECTORS.ocr_detector">
                    <div class="ui segment basic">
                        <label>
                            <p-checkbox v-model="detector.options.allow_reocr.value" :binary="true"></p-checkbox>
                            Allow Re-OCR <i class="ui icon question circle outline" v-tooltip="`Allow custom regenerating of the OCR when deemed useful. Useful to fix errors in IA OCR.`"></i>
                        </label>
    
                        <br>
                        <br>
                        <br>
    
                        <p-float-label>
                            <p-select
                                v-model="detector.options.ocr_engine.value"
                                :options="detector.options.ocr_engine.options"
                                :disabled="!detector.options.allow_reocr.value"
                            ></p-select>
                            <label>OCR Engine</label>
                        </p-float-label>
    
                        <p-message severity="warn" v-if="detector.options.ocr_engine.value === 'easyocr'">
                            <p>EasyOCR requires a GPU to run. If you don't have a GPU, please use Tesseract.</p>
                        </p-message>
                        <p-message severity="warn" v-else-if="detector.options.ocr_engine.value === 'tesseract'">
                            <p>Tesseract can perform poorly when detecting page numbers on a table of contents page, but runs on CPU.</p>
                        </p-message>
                    </div>
                </p-fieldset>
                <p-fieldset legend="AI Detector Options" :toggleable="true" v-else-if="detector == DETECTORS.ai_detector">
                    <div class="ui segment basic">
                        <p-float-label>
                            <p-select v-model="detector.options.model.value" :options="detector.options.model.options"></p-select>
                            <label>Model</label>
                        </p-float-label>
                        <br>
                        <div>
                            <label>Max Tokens <i class="ui icon question circle outline" v-tooltip="`The maximum number of tokens to generate. This is the maximum number of tokens the model will generate for the completion.`"></i></label>
                            <p-input-number v-model="detector.options.max_tokens.value" mode="decimal" :min="1" :max="500"></p-input-number>
                        </div>
                    </div>
                </p-fieldset>
                <p-fieldset legend="Manual Detector Options" :toggleable="true" v-else-if="detector == DETECTORS.manual_detector">
                    <blockquote>"Why don't you just tell me where the TOC is?"</blockquote>
                    <div class="ui segment basic">
                        <label>Leaf Numbers</label>
                        <p-input-text
                            v-model="detector.options.leaf_numbers.value_str"
                            placeholder="e.g. 1,2,3"
                            pattern="^\d+(, ?\d+)*$"
                        ></p-input-text>
                        <div class="carousel">
                            <div v-for="leaf in getLeafNumbersWithContext(detector.options.leaf_numbers.value)" :key="leaf.number">
                                <img :src="getImageUrl(leaf.number)" :class="{ 'greyed-out': leaf.greyedOut }" />
                                <p-tag>{{ leaf.number }}</p-tag>
                            </div>
                        </div>
                    </div>
                </p-fieldset>
            </p-fieldset>

            <p-fieldset legend="Extractor" :toggleable="true">
                <p>
                    Given the pages containing the table of contents, this phase is responsible
                    for converting those pages to a structured format.
                </p>
                <div class="ui segment basic">
                    <p-float-label>
                        <p-select v-model="extractor" :options="extractor_options" option-label="name"></p-select>
                        <label>Extractor</label>
                    </p-float-label>
                </div>
            </p-fieldset>

            <footer class="ui segment basic center">
                <p-message severity="error" v-if="state === 'Errored'">
                    <p>{{ error }}</p>
                </p-message>

                <p-message severity="error" v-if="response && !response.results.detector.success">
                    <details>
                        <summary>Error in Detector: <code>{{ response.results.detector.error }}</code></summary>
                        <pre>{{ response.results.detector.traceback }}</pre>
                    </details>
                </p-message>
                <p-message severity="success" v-else-if="response && response.results.detector.success">
                    Detector Success: {{ response.results.detector.result }}
                </p-message>

                <button
                    class="ui primary button"
                    @click="extractToc"
                    :class="{ loading: state === 'Submitting' }"
                    :disabled="state === 'Submitting'"
                >Extract TOC</button>
            </footer>
        </form>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/primevue/umd/primevue.min.js"></script>
    <script src="https://unpkg.com/@primevue/themes/umd/aura.min.js"></script>
    <script>
        const DETECTORS = {
            ocr_detector: {
                name: "OCR Detector",
                value: "ocr_detector",
                options: {
                    allow_reocr: {
                        value: true,
                    },
                    ocr_engine: {
                        value: "tesseract",
                        options: [
                            "tesseract",
                            "easyocr",
                        ]
                    }
                }
            },
            ai_detector: {
                name: "AI Detector",
                value: "ai_detector",
                options: {
                    model: {
                        value: 'gpt-4o-mini',
                        options: [
                            "gpt-4o-mini"
                        ]
                    },
                    max_tokens: {
                        value: 200,
                    }
                }
            },
            manual_detector: {
                name: "Manual Detector",
                value: "manual_detector",
                options: {
                    leaf_numbers: {
                        value: [],
                        
                        get value_str() {
                            return this.value.join(",");
                        },
                        set value_str(value) {
                            this.value = value.split(",").map(x => x.trim()).filter(x => x).map(x => parseFloat(x));
                        },
                    }
                }
            }
        };

        const EXTRACTORS = {
            ocr_extractor: {
                name: "OCR Extractor",
                value: "ocr_extractor",
                options: {},
            },
            ai_extractor: {
                name: "AI Extractor",
                value: "ai_extractor",
                options: {
                    model: {
                        value: 'gpt-4o-mini',
                        options: [
                            "gpt-4o-mini",
                            "gpt-3.5-turbo",
                        ]
                    }
                }
            }
        }
        window.app = Vue.createApp({
            data() {
                return {
                    ia_id: "",
                    ol_id: "",
                    state: "To Submit",
                    error: null,
                    response: null,
                    
                    DETECTORS: DETECTORS,
                    detector: DETECTORS.ocr_detector,
                    detector_options: Object.values(DETECTORS),

                    EXTRACTORS: EXTRACTORS,
                    extractor: EXTRACTORS.ocr_extractor,
                    extractor_options: Object.values(EXTRACTORS),
                };
            },

            mounted() {
                // read from url params if empty
                const urlParams = new URLSearchParams(window.location.search);
                this.ia_id = this.ia_id || urlParams.get("ia_id") || "";
                this.ol_id = this.ol_id || urlParams.get("ol_id") || "";
            },

            methods: {
                async extractToc() {
                    window.TOCKEY_API_KEY = (window.TOCKEY_API_KEY || prompt("Tocky API key"));

                    if (!window.TOCKEY_API_KEY) {
                        alert("Please provide a Tocky API key");
                        return;
                    }
                    this.state = "Submitting";
                    this.response = null;
                    this.error = null;
                    try {
                        const res = await fetch("/tocky/submit", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                'X-API-Key': window.TOCKEY_API_KEY,
                            },
                            body: JSON.stringify({
                                input_book: {
                                    ia_id: this.ia_id,
                                    ol_id: this.ol_id,
                                },
                                detector: {
                                    type: this.detector.value,
                                    options: Object.fromEntries(
                                        Object.entries(this.detector.options).map(([key, value]) => [key, value.value])
                                    )
                                },
                                extractor: {
                                    type: this.extractor.value,
                                    options: Object.fromEntries(
                                        Object.entries(this.extractor.options).map(([key, value]) => [key, value.value])
                                    )
                                }
                            })
                        });
                        if (!res.ok) {
                            throw new Error("Failed to extract TOC");
                        }
                        this.response = await res.json();
                    } catch (e) {
                        this.state = "Errored";
                        this.error = e;
                        console.error(e);
                    }
                    this.state = "Submitted";
                },
                getImageUrl(leafNumber) {
                    return `https://archive.org/download/${this.ia_id}/page/leaf${leafNumber}.jpg?scale=8`;
                },
                getLeafNumbersWithContext(leafNumbers) {
                    const numbers = leafNumbers.split(',').map(Number);
                    const minNumber = Math.min(...numbers);
                    const maxNumber = Math.max(...numbers);
                    const contextNumbers = [];
                    for (let i = minNumber - 2; i <= maxNumber + 2; i++) {
                        if (i > 0) {
                            contextNumbers.push({
                                number: i,
                                greyedOut: !numbers.includes(i)
                            });
                        }
                    }
                    return contextNumbers;
                }
            },
        });
        window.app.use(PrimeVue.Config, {
            theme: {
                preset: PrimeVue.Themes.Aura,
                options: {
                    prefix: 'p',
                    darkModeSelector: '.never',
                }
            }
        });

        window.app.component('p-select', PrimeVue.Select);
        window.app.component('p-float-label', PrimeVue.FloatLabel);
        window.app.component('p-fieldset', PrimeVue.Fieldset);
        window.app.directive('tooltip', PrimeVue.Tooltip);
        window.app.component('p-input-number', PrimeVue.InputNumber);
        window.app.component('p-checkbox', PrimeVue.Checkbox);
        window.app.component('p-message', PrimeVue.Message);
        window.app.component('p-select-button', PrimeVue.SelectButton);
        window.app.component('p-input-text', PrimeVue.InputText);
        window.app.component('p-tag', PrimeVue.Tag);

        window.app.mount("#app");
    </script>
</body>

</html>